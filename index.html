<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GeostreamDB - Geohash Viewer</title>

    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      .controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .mode-toggle {
        background: #fff;
        border: 2px solid rgba(0,0,0,0.2);
        border-radius: 6px;
        padding: 6px 12px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        box-shadow: 0 1px 5px rgba(0,0,0,0.15);
        transition: background 0.15s;
      }
      .mode-toggle:hover {
        background: #f3f4f6;
      }
      .mode-toggle:disabled {
        background: #f9fafb;
        color: #6b7280;
        cursor: default;
        opacity: 0.8;
      }
      .mode-toggle:disabled:hover {
        background: #f9fafb;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="controls">
      <button id="modeToggle" class="mode-toggle">Mode: Server</button>
      <button id="gridToggle" class="mode-toggle">Grid: On</button>
      <button id="precisionDisplay" class="mode-toggle" disabled>Precision: -</button>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const map = L.map("map", {
        preferCanvas: true,
        minZoom: 3,
        maxBounds: [[-90, -180], [90, 180]],
        maxBoundsViscosity: 1.0,
      }).setView([0, 0], 3);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
      }).addTo(map);

      const geohashLayer = L.featureGroup().addTo(map);
      const hoverLayer = L.featureGroup().addTo(map);  // Layer for hover drill-down
      const GATEWAY_BASE = window.location.origin.startsWith("http")
        ? window.location.origin
        : "http://localhost:8080";
      let latestPingArea = Object.create(null);
      let latestPingAreaMaxCount = 0;
      let precisionOverride = null;
      let displayMode = "server"; // "server" or "heatmap"
      let showGrid = true;
      let hoverAbortController = null;
      let currentHoverGh = null;

      const modeToggleBtn = document.getElementById("modeToggle");
      modeToggleBtn.addEventListener("click", () => {
        displayMode = displayMode === "server" ? "heatmap" : "server";
        modeToggleBtn.textContent = displayMode === "server" ? "Mode: Server" : "Mode: Heatmap";
        renderVisibleGeohashes();
      });

      const gridToggleBtn = document.getElementById("gridToggle");
      gridToggleBtn.addEventListener("click", () => {
        showGrid = !showGrid;
        gridToggleBtn.textContent = showGrid ? "Grid: On" : "Grid: Off";
        renderVisibleGeohashes();
      });

      const precisionDisplayBtn = document.getElementById("precisionDisplay");
      function updatePrecisionDisplay(precision) {
        precisionDisplayBtn.textContent = `Precision: ${precision}`;
      }

      // Minimal geohash decode (bbox) for browser use.
      // Returns [minLat, minLng, maxLat, maxLng]
      const GEOHASH_BASE32 = "0123456789bcdefghjkmnpqrstuvwxyz";
      const GEOHASH_MAP = (() => {
        const m = Object.create(null);
        for (let i = 0; i < GEOHASH_BASE32.length; i++) m[GEOHASH_BASE32[i]] = i;
        return m;
      })();

      function geohashDecodeBbox(gh) {
        if (typeof gh !== "string" || !gh.length) throw new Error("Empty geohash");
        let minLat = -90,
          maxLat = 90,
          minLng = -180,
          maxLng = 180;
        let isLng = true; // geohash bits start with longitude

        for (const chRaw of gh.toLowerCase()) {
          const v = GEOHASH_MAP[chRaw];
          if (v === undefined) throw new Error("Invalid geohash char: " + chRaw);
          for (let bit = 4; bit >= 0; bit--) {
            const mask = 1 << bit;
            if (isLng) {
              const mid = (minLng + maxLng) / 2;
              if (v & mask) minLng = mid;
              else maxLng = mid;
            } else {
              const mid = (minLat + maxLat) / 2;
              if (v & mask) minLat = mid;
              else maxLat = mid;
            }
            isLng = !isLng;
          }
        }
        return [minLat, minLng, maxLat, maxLng];
      }

      function clamp(n, min, max) {
        return Math.min(max, Math.max(min, n));
      }

      function geohashEncode(latRaw, lngRaw, precision) {
        const lat = clamp(Number(latRaw), -90, 90);
        const lng = clamp(Number(lngRaw), -180, 180);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) throw new Error("Invalid lat/lng");
        if (!Number.isInteger(precision) || precision < 1) throw new Error("Invalid precision");

        let minLat = -90,
          maxLat = 90,
          minLng = -180,
          maxLng = 180;
        let isLng = true;
        let out = "";
        let ch = 0;
        let bit = 0;

        while (out.length < precision) {
          if (isLng) {
            const mid = (minLng + maxLng) / 2;
            if (lng >= mid) {
              ch = (ch << 1) | 1;
              minLng = mid;
            } else {
              ch = (ch << 1) | 0;
              maxLng = mid;
            }
          } else {
            const mid = (minLat + maxLat) / 2;
            if (lat >= mid) {
              ch = (ch << 1) | 1;
              minLat = mid;
            } else {
              ch = (ch << 1) | 0;
              maxLat = mid;
            }
          }

          isLng = !isLng;
          bit++;
          if (bit === 5) {
            out += GEOHASH_BASE32[ch];
            bit = 0;
            ch = 0;
          }
        }
        return out;
      }

      function geohashCellSize(precision) {
        const totalBits = precision * 5;
        const lngBits = Math.ceil(totalBits / 2);
        const latBits = Math.floor(totalBits / 2);
        return {
          latHeight: 180 / Math.pow(2, latBits),
          lngWidth: 360 / Math.pow(2, lngBits),
        };
      }

      function precisionForZoom(z) {
        if (z <= 2) return 2;
        if (z <= 4) return 3;
        if (z <= 6) return 4;
        if (z <= 8) return 5;
        if (z <= 10) return 6;
        if (z <= 12) return 7;
        return 8;
      }

      function estimateCellCount(bounds, precision) {
        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        const { latHeight, lngWidth } = geohashCellSize(precision);

        const minLat = clamp(sw.lat, -90, 90);
        const maxLat = clamp(ne.lat, -90, 90);
        const latMinIdx = Math.floor((minLat + 90) / latHeight);
        const latMaxIdx = Math.floor((maxLat + 90) / latHeight);
        const latCount = Math.max(0, latMaxIdx - latMinIdx + 1);

        const ranges = sw.lng <= ne.lng ? [[sw.lng, ne.lng]] : [[sw.lng, 180], [-180, ne.lng]];
        let lngCount = 0;
        for (const [a, b] of ranges) {
          const minLng = clamp(a, -180, 180);
          const maxLng = clamp(b, -180, 180);
          const lngMinIdx = Math.floor((minLng + 180) / lngWidth);
          const lngMaxIdx = Math.floor((maxLng + 180) / lngWidth);
          lngCount += Math.max(0, lngMaxIdx - lngMinIdx + 1);
        }

        return latCount * lngCount;
      }

      function choosePrecision(bounds) {
        let precision = precisionForZoom(map.getZoom());
        const MAX_CELLS = 5000;
        while (precision > 1 && estimateCellCount(bounds, precision) > MAX_CELLS) precision--;
        if (precisionOverride && precisionOverride < precision) precision = precisionOverride;
        return precision;
      }

      function hashStringToInt(s) {
        let h = 2166136261;
        for (let i = 0; i < s.length; i++) {
          h ^= s.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }

      function colorForServer(server) {
        const key = String(server || "unknown");
        const hash = hashStringToInt(key);
        
        // Use golden ratio for better color distribution
        const GOLDEN_RATIO = 0.618033988749895;
        const hue = (hash * GOLDEN_RATIO) % 1 * 360;
        
        // Vary saturation (70-100%) and lightness (40-60%) for more distinction
        const sat = 70 + (hash % 31); // 70-100%
        const light = 40 + (Math.floor(hash / 31) % 21); // 40-60%
        
        return `hsl(${Math.floor(hue)} ${sat}% ${light}%)`;
      }

      function heatmapColor(count, maxCount) {
        // gradient: blue (low) → cyan → green → yellow → red (high)
        if (!Number.isFinite(count) || count <= 0) return "hsl(240 70% 50%)"; // blue
        // use a floor so low counts don't immediately appear red
        const effectiveMax = Math.max(maxCount || 1, 10);
        const ratio = Math.min(1, count / effectiveMax);
        // map ratio 0→1 to hue 240→0 (blue→red)
        const h = 240 - ratio * 240;
        return `hsl(${h} 80% 50%)`;
      }

      function opacityForCount(count, maxCount) {
        const minO = 0.12;
        const maxO = 0.72;
        if (!Number.isFinite(count) || count <= 0) return minO;
        if (!Number.isFinite(maxCount) || maxCount <= 0) return maxO;
        return minO + (maxO - minO) * Math.min(1, count / maxCount);
      }

      function buildPingAreaUrl({ minLat, minLng, maxLat, maxLng, precision }) {
        const u = new URL("/pingArea", GATEWAY_BASE);
        u.searchParams.set("precision", String(precision));
        u.searchParams.set("minLat", String(minLat));
        u.searchParams.set("minLng", String(minLng));
        u.searchParams.set("maxLat", String(maxLat));
        u.searchParams.set("maxLng", String(maxLng));
        return u.toString();
      }

      function buildPingUrl() {
        const u = new URL("/ping", GATEWAY_BASE);
        return u.toString();
      }

      async function sendPing(lat, lng) {
        const res = await fetch(buildPingUrl(), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ lat, lng }),
        });
        return res;
      }

      async function showHoverDetails(gh, cellBounds, basePrecision) {
        if (currentHoverGh === gh) return;  // Already showing this cell
        currentHoverGh = gh;

        // Cancel previous hover fetch
        if (hoverAbortController) hoverAbortController.abort();
        hoverAbortController = new AbortController();

        hoverLayer.clearLayers();

        // Fetch at +2 precision (finer detail)
        const hoverPrecision = Math.min(basePrecision + 2, 8);
        if (hoverPrecision <= basePrecision) return;

        const sw = cellBounds.getSouthWest();
        const ne = cellBounds.getNorthEast();

        try {
          const url = buildPingAreaUrl({
            minLat: sw.lat,
            maxLat: ne.lat,
            minLng: sw.lng,
            maxLng: ne.lng,
            precision: hoverPrecision,
          });
          const res = await fetch(url, { signal: hoverAbortController.signal });
          if (!res.ok) return;
          const data = await res.json();
          if (!data || typeof data !== "object") return;

          // Find max count for this hover set
          let hoverMax = 0;
          for (const v of Object.values(data)) {
            const c = Number(v && (v.Count ?? v.count) || 0);
            if (c > hoverMax) hoverMax = c;
          }

          // Render finer cells
          for (const [fineGh, v] of Object.entries(data)) {
            if (!v) continue;
            try {
              const bbox = geohashDecodeBbox(fineGh);
              const fineBounds = L.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]);
              const count = Number(v.Count ?? v.count ?? 0);
              const server = String(v.Server ?? v.Hostname ?? v.server ?? v.hostname ?? "");
              const color = displayMode === "server" ? colorForServer(server) : heatmapColor(count, hoverMax);
              const opacity = displayMode === "server" ? 0.6 : opacityForCount(count, hoverMax);

              const rect = L.rectangle(fineBounds, {
                weight: 2,
                color: "#000",
                fillColor: color,
                fillOpacity: opacity + 0.1,
              });
              const tooltipText = displayMode === "server" && server
                ? `${fineGh}<br>Count: ${count}<br>Server: ${server}`
                : `${fineGh}<br>Count: ${count}`;
              rect.bindTooltip(tooltipText, { sticky: true });
              rect.addTo(hoverLayer);
            } catch (e) { /* ignore decode errors */ }
          }
        } catch (e) {
          if (e && e.name === "AbortError") return;
        }
      }

      function hideHoverDetails() {
        if (hoverAbortController) hoverAbortController.abort();
        hoverAbortController = null;
        currentHoverGh = null;
        hoverLayer.clearLayers();
      }

      async function fetchPingAreaForBounds(bounds, precision, signal) {
        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();

        const minLat = clamp(sw.lat, -90, 90);
        const maxLat = clamp(ne.lat, -90, 90);

        const EPS_LNG = 1e-6;
        let minLng0 = clamp(sw.lng, -180, 180);
        let maxLng0 = clamp(ne.lng, -180, 180);
        // Avoid the special-case where Leaflet produces [-180, 180] which the gateway treats as ~0 width (same meridian).
        if (minLng0 <= -180 + EPS_LNG && maxLng0 >= 180 - EPS_LNG) {
          minLng0 = -180 + EPS_LNG;
          maxLng0 = 180 - EPS_LNG;
        }

        const lngRanges = minLng0 <= maxLng0 ? [[minLng0, maxLng0]] : [[minLng0, 180], [-180, maxLng0]];

        const merged = Object.create(null);
        for (const [rawMinLng, rawMaxLng] of lngRanges) {
          const minLng = clamp(rawMinLng, -180, 180);
          const maxLng = clamp(rawMaxLng, -180, 180);

          const url = buildPingAreaUrl({ minLat, minLng, maxLat, maxLng, precision });
          const res = await fetch(url, { signal });
          if (!res.ok) {
            const err = new Error(`pingArea failed: ${res.status}`);
            err.status = res.status;
            throw err;
          }
          const json = await res.json();
          if (!json || typeof json !== "object") continue;

          for (const [gh, v] of Object.entries(json)) {
            if (!v || typeof v !== "object") continue;
            const count = Number(v.Count ?? v.count ?? 0);
            const server = String(v.Server ?? v.Hostname ?? v.server ?? v.hostname ?? "");

            if (!merged[gh]) {
              merged[gh] = { count: 0, server };
            }
            merged[gh].count += Number.isFinite(count) ? count : 0;
            if (!merged[gh].server && server) merged[gh].server = server;
          }
        }

        return merged;
      }

      function renderVisibleGeohashes() {
        const bounds = map.getBounds();
        const precision = choosePrecision(bounds);
        updatePrecisionDisplay(precision);

        geohashLayer.clearLayers();

        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        const { latHeight, lngWidth } = geohashCellSize(precision);

        const minLat = clamp(sw.lat, -90, 90);
        const maxLat = clamp(ne.lat, -90, 90);
        const latMinIdx = Math.floor((minLat + 90) / latHeight);
        const latMaxIdx = Math.floor((maxLat + 90) / latHeight);

        const lngRanges = sw.lng <= ne.lng ? [[sw.lng, ne.lng]] : [[sw.lng, 180], [-180, ne.lng]];

        const seen = new Set();
        for (let latIdx = latMinIdx; latIdx <= latMaxIdx; latIdx++) {
          const cellMinLat = -90 + latIdx * latHeight;
          const cellMaxLat = cellMinLat + latHeight;
          const centerLat = (cellMinLat + cellMaxLat) / 2;

          for (const [rMin, rMax] of lngRanges) {
            const minLng = clamp(rMin, -180, 180);
            const maxLng = clamp(rMax, -180, 180);
            const lngMinIdx = Math.floor((minLng + 180) / lngWidth);
            const lngMaxIdx = Math.floor((maxLng + 180) / lngWidth);

            for (let lngIdx = lngMinIdx; lngIdx <= lngMaxIdx; lngIdx++) {
              const cellMinLng = -180 + lngIdx * lngWidth;
              const cellMaxLng = cellMinLng + lngWidth;
              const centerLng = (cellMinLng + cellMaxLng) / 2;

              const gh = geohashEncode(centerLat, centerLng, precision);
              if (seen.has(gh)) continue;
              seen.add(gh);

              const bbox = geohashDecodeBbox(gh);
              const cellBounds = L.latLngBounds(
                [bbox[0], bbox[1]],
                [bbox[2], bbox[3]]
              );
              const v = latestPingArea && latestPingArea[gh] ? latestPingArea[gh] : null;
              if (v) {
                const count = Number(v.count);
                const server = String(v.server || "");
                const color = displayMode === "server"
                  ? colorForServer(server)
                  : heatmapColor(count, latestPingAreaMaxCount);
                const opacity = displayMode === "server" ? 0.6 : opacityForCount(count, latestPingAreaMaxCount);
                const rect = L.rectangle(cellBounds, {
                  weight: 1,
                  color,
                  fillColor: color,
                  fillOpacity: opacity,
                });
                // Add hover handlers for drill-down
                rect.on("mouseover", () => showHoverDetails(gh, cellBounds, precision));
                rect.on("mouseout", hideHoverDetails);
                const tooltipText = displayMode === "server" && server
                  ? `${gh}<br>Count: ${count}<br>Server: ${server}`
                  : `${gh}<br>Count: ${count}`;
                rect.bindTooltip(tooltipText, { sticky: true });
                rect.addTo(geohashLayer);
              } else if (showGrid) {
                L.rectangle(cellBounds, { weight: 1, color: "#2563eb", fillOpacity: 0.08 }).addTo(
                  geohashLayer
                );
              }
            }
          }
        }
      }

      let pollController = null;
      async function pollPingArea() {
        if (pollController) pollController.abort();
        pollController = new AbortController();

        const bounds = map.getBounds();
        let precision = choosePrecision(bounds);

        while (precision >= 1) {
          try {
            const data = await fetchPingAreaForBounds(bounds, precision, pollController.signal);
            latestPingArea = data || Object.create(null);
            let maxCount = 0;
            for (const v of Object.values(latestPingArea)) {
              const c = Number(v && v.count);
              if (Number.isFinite(c) && c > maxCount) maxCount = c;
            }
            latestPingAreaMaxCount = maxCount;
            precisionOverride = null;
            renderVisibleGeohashes();
            return;
          } catch (e) {
            if (e && e.name === "AbortError") return;
            if (e && e.status === 413 && precision > 1) {
              precision--;
              precisionOverride = precision;
              continue;
            }
            // Any other error (400, 500, network, etc.) - just stop this poll cycle; interval will retry.
            return;
          }
        }
      }

      map.on("moveend zoomend", () => {
        precisionOverride = null;
        renderVisibleGeohashes();
        pollPingArea();
      });

      // Right-click anywhere on the map to send a ping to that coordinate.
      map.on("contextmenu", async (e) => {
        try {
          const { lat, lng } = e.latlng;
          const res = await sendPing(lat, lng);
          if (res && res.ok) {
            pollPingArea();
          }
        } catch (e) {
          // ignore
        }
      });

      renderVisibleGeohashes();
      pollPingArea();
      setInterval(pollPingArea, 2000);
    </script>
  </body>
</html>
